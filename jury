#!/usr/bin/env ruby

require_relative 'lib/environment'
require_relative 'lib/argument_parser'
require_relative 'lib/interactions'

class Jury
  include Interactions
  attr_reader :options

  def initialize
    @options = ArgumentParser.parse
    Environment.environment = @options[:environment] || "production"
  end

  def main
    database = Environment.database_connection

    if options[:command] == "search"
      search_term = ask("Enter all or part of a song name to search for:")

      puts "Searching for: #{search_term}"
      statement = "select songs.name from songs where name LIKE '%#{search_term}%'"
      results = database.execute(statement)
      puts results
    elsif options[:command] == "add"
      error_messages = ArgumentParser.validate(options)
      if error_messages.empty?
        song = Song.new(options)
        song.save
        puts "A song by #{options[:artist]} was added, named '#{options[:name]}'."
        puts "It's in the #{options[:genre]} genre, with intensity of #{options[:intensity]} and focusing value of #{options[:focusing]}."
      else
        puts error_messages
      end
    elsif options[:command] == "list"
      list_songs()
    elsif options[:command] == "edit"
      if song = Song.find(options[:id])
        song.update(options)
        puts "Song #{song.id} by #{song.artist} is now named '#{song.name}'."
        puts "It's in the #{song.genre} genre, with intensity of #{song.intensity} and focusing value of #{song.focusing}."
      else
        puts "Song #{options[:id]} couldn't be found."
      end
    else
        puts "Available commands are 'add', 'edit', 'list', and 'search.'"
    end
  end

  def list_songs()
    puts "Songs in the database:"
    puts Song.all
  end
end

jury = Jury.new()
jury.main()
